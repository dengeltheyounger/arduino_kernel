\hypertarget{memory_8h_source}{}\doxysection{memory.\+h}
\label{memory_8h_source}\index{include/mem/memory.h@{include/mem/memory.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{preprocessor}{\#ifndef MEMORY\_H}}
\DoxyCodeLine{2 \textcolor{preprocessor}{\#define MEMORY\_H}}
\DoxyCodeLine{3 \textcolor{preprocessor}{\#include <avr/io.h>}}
\DoxyCodeLine{4 \textcolor{preprocessor}{\#include "{}sys/tasks.h"{}}}
\DoxyCodeLine{5 \textcolor{preprocessor}{\#include "{}memory\_request.h"{}}}
\DoxyCodeLine{6 }
\DoxyCodeLine{7 \textcolor{preprocessor}{\#define EEPROM\_PGSIZE       4}}
\DoxyCodeLine{8 \textcolor{preprocessor}{\#define EEPROM\_PGCOUNT      250}}
\DoxyCodeLine{9 \textcolor{preprocessor}{\#define FLASH\_WORD\_PGSIZE   64}}
\DoxyCodeLine{10 \textcolor{preprocessor}{\#define FLASH\_WORD\_PGCOUNT  256}}
\DoxyCodeLine{11 }
\DoxyCodeLine{12 }
\DoxyCodeLine{13 \textcolor{comment}{/* The reason why I use this macro is because}}
\DoxyCodeLine{14 \textcolor{comment}{ * it may save on memory in the event that}}
\DoxyCodeLine{15 \textcolor{comment}{ * the user does not desire to use any of the}}
\DoxyCodeLine{16 \textcolor{comment}{ * memory io functions. }}
\DoxyCodeLine{17 \textcolor{comment}{ *}}
\DoxyCodeLine{18 \textcolor{comment}{ * Given the power of GCC, it is likely that }}
\DoxyCodeLine{19 \textcolor{comment}{ * it will disinclude any memory io functions that}}
\DoxyCodeLine{20 \textcolor{comment}{ * are not used anyway. However, this maybe this will}}
\DoxyCodeLine{21 \textcolor{comment}{ * add a little safeguard, just in case (or maybe its}}
\DoxyCodeLine{22 \textcolor{comment}{ * inefficient)}}
\DoxyCodeLine{23 \textcolor{comment}{ */}}
\DoxyCodeLine{24 }
\DoxyCodeLine{25 \textcolor{preprocessor}{\#ifdef MEMORY\_REQUESTED}}
\DoxyCodeLine{26 }
\DoxyCodeLine{27 \textcolor{keyword}{enum} memory\_space \{}
\DoxyCodeLine{28     eeprom = 1,}
\DoxyCodeLine{29     flash = 2}
\DoxyCodeLine{30 \};}
\DoxyCodeLine{31 }
\DoxyCodeLine{32 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} eeprom\_read\_byte(\textcolor{keywordtype}{void} *addr) \{}
\DoxyCodeLine{33 }
\DoxyCodeLine{34     \textcolor{comment}{// Wait for completion of previous write}}
\DoxyCodeLine{35     \textcolor{keywordflow}{while} (EECR \& (1 << EEPE));}
\DoxyCodeLine{36 }
\DoxyCodeLine{37     \textcolor{comment}{// Set up address register}}
\DoxyCodeLine{38     EEAR = (uint16\_t) addr;}
\DoxyCodeLine{39 }
\DoxyCodeLine{40     \textcolor{comment}{/* This might be an area where a read can}}
\DoxyCodeLine{41 \textcolor{comment}{     * fail if an interrupt is generated. I}}
\DoxyCodeLine{42 \textcolor{comment}{     * don't really know, to be honest.}}
\DoxyCodeLine{43 \textcolor{comment}{     */}}
\DoxyCodeLine{44     \textcolor{keyword}{asm}(\textcolor{stringliteral}{"{}cli\(\backslash\)n\(\backslash\)t"{}});}
\DoxyCodeLine{45     \textcolor{comment}{// Start eeprom read by}}
\DoxyCodeLine{46     EECR |= (1 << EERE);}
\DoxyCodeLine{47     \textcolor{keyword}{asm}(\textcolor{stringliteral}{"{}sei\(\backslash\)n\(\backslash\)t"{}});}
\DoxyCodeLine{48 }
\DoxyCodeLine{49     \textcolor{comment}{// Return data from data register}}
\DoxyCodeLine{50     \textcolor{keywordflow}{return} EEDR;}
\DoxyCodeLine{51 \}}
\DoxyCodeLine{52 }
\DoxyCodeLine{53 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} eeprom\_read(\textcolor{keywordtype}{void} *addr,}
\DoxyCodeLine{54                 uint16\_t begin,}
\DoxyCodeLine{55                 uint16\_t end,}
\DoxyCodeLine{56                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *buffer) \{}
\DoxyCodeLine{57 }
\DoxyCodeLine{58     \textcolor{comment}{/* Read the total number of requested bytes from eeprom}}
\DoxyCodeLine{59 \textcolor{comment}{     * into buffer}}
\DoxyCodeLine{60 \textcolor{comment}{     */}}
\DoxyCodeLine{61     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = begin; i < end; ++i) \{}
\DoxyCodeLine{62         buffer[i] = eeprom\_read\_byte((\textcolor{keywordtype}{void} *) }
\DoxyCodeLine{63                         ((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}) addr + i));}
\DoxyCodeLine{64     \}}
\DoxyCodeLine{65 \}}
\DoxyCodeLine{66 }
\DoxyCodeLine{67 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} eeprom\_write\_byte(\textcolor{keywordtype}{void} *addr,}
\DoxyCodeLine{68                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} data) \{}
\DoxyCodeLine{69 }
\DoxyCodeLine{70     \textcolor{comment}{// This came from the data sheet}}
\DoxyCodeLine{71     \textcolor{comment}{// Wait for completion of previous write}}
\DoxyCodeLine{72     \textcolor{keywordflow}{while} (EECR \& (1 << EEPE));}
\DoxyCodeLine{73 }
\DoxyCodeLine{74     \textcolor{comment}{// Write new EEPROM address to EEAR}}
\DoxyCodeLine{75     EEAR = (uint16\_t) addr;}
\DoxyCodeLine{76 }
\DoxyCodeLine{77     \textcolor{comment}{// Write new EEPROM data to EEDR}}
\DoxyCodeLine{78     EEDR = data;}
\DoxyCodeLine{79     }
\DoxyCodeLine{80     \textcolor{comment}{/* During this portion, it is important to clear interrupts in order to}}
\DoxyCodeLine{81 \textcolor{comment}{     * ensure write success}}
\DoxyCodeLine{82 \textcolor{comment}{     */}}
\DoxyCodeLine{83     \textcolor{keyword}{asm}(\textcolor{stringliteral}{"{}cli\(\backslash\)n\(\backslash\)t"{}});}
\DoxyCodeLine{84     \textcolor{comment}{// Write a logical one to the EEMPE bit while writing a zero to EEPE in EECR}}
\DoxyCodeLine{85     EECR |= (1 << EEMPE);}
\DoxyCodeLine{86     EECR |= (1 << EEPE);}
\DoxyCodeLine{87     \textcolor{keyword}{asm}(\textcolor{stringliteral}{"{}sei\(\backslash\)n\(\backslash\)t"{}});}
\DoxyCodeLine{88 }
\DoxyCodeLine{89     \textcolor{keywordflow}{return};}
\DoxyCodeLine{90 \}}
\DoxyCodeLine{91 }
\DoxyCodeLine{92 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} eeprom\_write(\textcolor{keywordtype}{void} *addr,}
\DoxyCodeLine{93                 uint16\_t begin,}
\DoxyCodeLine{94                 uint16\_t end,}
\DoxyCodeLine{95                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *data) \{}
\DoxyCodeLine{96     }
\DoxyCodeLine{97     \textcolor{comment}{// Write each byte to eeprom}}
\DoxyCodeLine{98     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = begin; i < end; ++i) \{}
\DoxyCodeLine{99         eeprom\_write\_byte((\textcolor{keywordtype}{void} *)((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}) addr + i), data[i]);}
\DoxyCodeLine{100     \}}
\DoxyCodeLine{101 }
\DoxyCodeLine{102     \textcolor{keywordflow}{return};}
\DoxyCodeLine{103 \}}
\DoxyCodeLine{104     }
\DoxyCodeLine{105 \textcolor{comment}{/* The idea is that the programmer will fill a}}
\DoxyCodeLine{106 \textcolor{comment}{ * datastructure that will contain the task's id (an index}}
\DoxyCodeLine{107 \textcolor{comment}{ * for the set of tasks), as well as the desired}}
\DoxyCodeLine{108 \textcolor{comment}{ * size for eeprom (0 if none) and the desired size}}
\DoxyCodeLine{109 \textcolor{comment}{ * for the flash. From here, the kernel is able to }}
\DoxyCodeLine{110 \textcolor{comment}{ * infer where the task's location in memory is.}}
\DoxyCodeLine{111 \textcolor{comment}{ *}}
\DoxyCodeLine{112 \textcolor{comment}{ * If the there is an error, the kernel will return}}
\DoxyCodeLine{113 \textcolor{comment}{ * 0 (false). Eventually, it would be useful for me}}
\DoxyCodeLine{114 \textcolor{comment}{ * to include error codes in these functions.}}
\DoxyCodeLine{115 \textcolor{comment}{ */}}
\DoxyCodeLine{116 }
\DoxyCodeLine{117 }
\DoxyCodeLine{118 \textcolor{comment}{/* Memory write will write the buffer to the task's}}
\DoxyCodeLine{119 \textcolor{comment}{ * space.}}
\DoxyCodeLine{120 \textcolor{comment}{ *}}
\DoxyCodeLine{121 \textcolor{comment}{ * The begin and end is used in order to determine where within the buffer}}
\DoxyCodeLine{122 \textcolor{comment}{ * to begin and end. This can be used to get a slice of data within the}}
\DoxyCodeLine{123 \textcolor{comment}{ * buffer if not all is needed.}}
\DoxyCodeLine{124 \textcolor{comment}{ *}}
\DoxyCodeLine{125 \textcolor{comment}{ * 1 indicates success}}
\DoxyCodeLine{126 \textcolor{comment}{ * 0 indicates error}}
\DoxyCodeLine{127 \textcolor{comment}{ */}}
\DoxyCodeLine{128 \textcolor{keywordtype}{int} memory\_write(\textcolor{keywordtype}{int} task\_id, }
\DoxyCodeLine{129         \textcolor{keyword}{enum} memory\_space zone,}
\DoxyCodeLine{130         uint16\_t begin,}
\DoxyCodeLine{131         uint16\_t end,}
\DoxyCodeLine{132         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *buffer);}
\DoxyCodeLine{133 }
\DoxyCodeLine{134 \textcolor{comment}{/* read contents of task's memory space}}
\DoxyCodeLine{135 \textcolor{comment}{ * into the buffer. This will mean either}}
\DoxyCodeLine{136 \textcolor{comment}{ * the entire memory space or the number of}}
\DoxyCodeLine{137 \textcolor{comment}{ * bytes, whichever is smallest.}}
\DoxyCodeLine{138 \textcolor{comment}{ * }}
\DoxyCodeLine{139 \textcolor{comment}{ * 1 indicates success}}
\DoxyCodeLine{140 \textcolor{comment}{ * 0 indicates error}}
\DoxyCodeLine{141 \textcolor{comment}{ */}}
\DoxyCodeLine{142 \textcolor{keywordtype}{int} memory\_read(\textcolor{keywordtype}{int} task\_id,}
\DoxyCodeLine{143         \textcolor{keyword}{enum} memory\_space zone,}
\DoxyCodeLine{144         uint16\_t begin,}
\DoxyCodeLine{145         uint16\_t end,}
\DoxyCodeLine{146         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *buffer);}
\DoxyCodeLine{147 }
\DoxyCodeLine{148 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{149 \textcolor{preprocessor}{\#endif}}

\end{DoxyCode}
